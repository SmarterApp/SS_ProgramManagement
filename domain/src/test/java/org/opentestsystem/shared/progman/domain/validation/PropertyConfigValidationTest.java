/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.shared.progman.domain.validation;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.List;
import java.util.Set;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;

import org.junit.BeforeClass;
import org.junit.Test;
import org.opentestsystem.shared.progman.domain.PropertyConfig;
import org.opentestsystem.shared.progman.domain.PropertyEntry;

import com.google.common.collect.Lists;

/**
 * Tests PropertyConfig domain object for validation errors.
 */
public class PropertyConfigValidationTest {

    private static final String ERROR_MUST_EXIST = "Error must exist";
    private static final String VALID = "valid";
    private static final String ONE_ERROR = "One validation error should exist";
    private static final String ZERO_ERRORS = "No validation errors should exist";
    private static final String TWO_ERRORS = "Two validation errors should exist";
    private static final String PROP = "prop";
    private static final String SIXTY_CHARS = "123456789_123456789_123456789_123456789_123456789_123456789_";
    private static final String PROP_ERROR_STILL = "Error must still exist because property key is blank";

    private static Validator validator;

    @BeforeClass
    public static void setUp() {
        validator = Validation.buildDefaultValidatorFactory().getValidator();
    }

    @Test
    public void testRequiredFields() {
        Set<ConstraintViolation<PropertyEntry>> propErrors;

        PropertyEntry prop = new PropertyEntry();
        propErrors = validator.validate(prop);
        assertNotNull(ERROR_MUST_EXIST, propErrors);
        assertEquals(ONE_ERROR, 1, propErrors.size());

        prop = new PropertyEntry(VALID, "key");
        propErrors = validator.validate(prop);
        assertNotNull(ERROR_MUST_EXIST, propErrors);
        assertEquals(ZERO_ERRORS, 0, propErrors.size());
        propErrors.clear();

        prop = new PropertyEntry(null, null);
        propErrors = validator.validate(prop);
        assertNotNull(ERROR_MUST_EXIST, propErrors);
        assertEquals(ONE_ERROR, 1, propErrors.size());
        propErrors.clear();

        prop = new PropertyEntry("foo", null);
        propErrors = validator.validate(prop);
        assertNotNull(ERROR_MUST_EXIST, propErrors);
        assertEquals(ZERO_ERRORS, 0, propErrors.size());
        propErrors.clear();

        prop = new PropertyEntry("", "key");
        propErrors = validator.validate(prop);
        assertNotNull(ERROR_MUST_EXIST, propErrors);
        assertEquals(ONE_ERROR, 1, propErrors.size());
        propErrors.clear();

        PropertyConfig config = new PropertyConfig();
        Set<ConstraintViolation<PropertyConfig>> errors;
        errors = validator.validate(config);
        assertNotNull(ERROR_MUST_EXIST, errors);
        errors.clear();

        config.setEnvName("DEV");
        errors = validator.validate(config);
        assertNotNull("Error must still exist because properties & name is null", errors);
        assertEquals(TWO_ERRORS, 2, errors.size());
        errors.clear();

        config.setName("test_config");
        errors = validator.validate(config);
        assertNotNull("Error must still exist because properties are null", errors);
        assertEquals(ONE_ERROR, 1, errors.size());
        errors.clear();

        List<PropertyEntry> properties = Lists.newArrayList();
        config.addProperty("smtp.tib.hostname", "");
        config.setProperties(properties);
        errors = validator.validate(config);
        assertNotNull("Error must still exist because property value is blank", errors);
        assertEquals(ONE_ERROR, 1, errors.size());
        errors.clear();

        properties.clear();
        config.addProperty("", "foo");
        config.addProperty(VALID, PROP);
        config.setProperties(properties);
        errors = validator.validate(config);
        assertNotNull(PROP_ERROR_STILL, errors);
        assertEquals(ONE_ERROR, 1, errors.size());
        errors.clear();

        properties.clear();
        config.addProperty("bar", "");
        config.addProperty(VALID, PROP);
        config.setProperties(properties);
        errors = validator.validate(config);
        assertNotNull(PROP_ERROR_STILL, errors);
        assertEquals(ZERO_ERRORS, 0, errors.size());
        errors.clear();

        properties.clear();
        config.addProperty(null, null);
        config.addProperty(VALID, PROP);
        config.setProperties(properties);
        errors = validator.validate(config);
        assertNotNull(PROP_ERROR_STILL, errors);
        assertEquals(ONE_ERROR, 1, errors.size());
        errors.clear();

        properties.clear();
        config.addProperty("", "");
        config.addProperty(VALID, PROP);
        config.setProperties(properties);
        errors = validator.validate(config);
        assertNotNull(PROP_ERROR_STILL, errors);
        assertEquals(ONE_ERROR, 1, errors.size());
        errors.clear();

        List<PropertyEntry> properties1 = Lists.newArrayList();
        PropertyEntry entry = new PropertyEntry();
        entry.setPropertyKey("smtp.tib.hostname");
        entry.setPropertyValue("localhost");
        properties1.add(entry);
        config.setProperties(properties1);
        errors = validator.validate(config);
        assertEquals(ZERO_ERRORS, 0, errors.size());
        errors.clear();
    }

    private PropertyConfig getValidPropertyConfig() {
        PropertyConfig config = new PropertyConfig();
        config.setName("configName");
        config.setEnvName("envName");

        PropertyEntry oneEntry = new PropertyEntry();
        oneEntry.setPropertyKey("foo.bar.key");
        oneEntry.setPropertyValue("dude");
        config.setProperties(Arrays.asList(new PropertyEntry[] {oneEntry }));
        return config;

    }

    @Test
    public void testNameStringLength() {
        Set<ConstraintViolation<PropertyConfig>> configErrors;

        PropertyConfig config = getValidPropertyConfig();

        configErrors = validator.validate(config);
        assertNotNull(ERROR_MUST_EXIST, configErrors);
        assertEquals(ZERO_ERRORS, 0, configErrors.size());
        configErrors.clear();

        config.setName(SIXTY_CHARS + "1");
        configErrors = validator.validate(config);
        assertNotNull(ERROR_MUST_EXIST, configErrors);
        assertEquals(ONE_ERROR, 1, configErrors.size());
        assertTrue("expected message not found", hasMessage(configErrors, "propertyConfig.name.length"));
        configErrors.clear();

        config.setName(SIXTY_CHARS);
        configErrors = validator.validate(config);
        assertNotNull(ERROR_MUST_EXIST, configErrors);
        assertEquals(ZERO_ERRORS, 0, configErrors.size());
        configErrors.clear();
    }

    @Test
    public void testEnvNameStringLength() {
        Set<ConstraintViolation<PropertyConfig>> configErrors;

        PropertyConfig config = getValidPropertyConfig();

        configErrors = validator.validate(config);
        assertNotNull(ERROR_MUST_EXIST, configErrors);
        assertEquals(ZERO_ERRORS, 0, configErrors.size());
        configErrors.clear();

        config.setEnvName(SIXTY_CHARS + "1");
        configErrors = validator.validate(config);
        assertNotNull(ERROR_MUST_EXIST, configErrors);
        assertEquals(ONE_ERROR, 1, configErrors.size());
        assertTrue("expected message not found", hasMessage(configErrors, "propertyConfig.envName.length"));
        configErrors.clear();

        config.setEnvName(SIXTY_CHARS);
        configErrors = validator.validate(config);
        assertNotNull(ERROR_MUST_EXIST, configErrors);
        assertEquals(ZERO_ERRORS, 0, configErrors.size());
        configErrors.clear();
    }

    private boolean hasMessage(final Set<ConstraintViolation<PropertyConfig>> configErrors, final String message) {
        boolean valid = false;
        for (ConstraintViolation<?> validation : configErrors) {
            if (message.equals(validation.getMessageTemplate())) {
                valid = true;
                break;
            }
        }
        return valid;
    }

}
