/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.shared.progman.integration;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.List;
import java.util.Map;

import javax.validation.ConstraintViolationException;

import org.bson.types.ObjectId;
import org.joda.time.DateTime;
import org.junit.Test;
import org.opentestsystem.shared.progman.domain.Tenant;
import org.opentestsystem.shared.progman.domain.TenantSubscription;
import org.opentestsystem.shared.progman.domain.TenantType;
import org.opentestsystem.shared.progman.persistence.TenantRepository;
import org.opentestsystem.shared.progman.transformer.TenantBuilder;
import org.opentestsystem.shared.progman.transformer.TenantSubscriptionBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

public class TenantRepositoryTest extends AbstractPersistenceEmbeddedTest {

    @Autowired
    private TenantRepository tenantRepository;

    @Test
    public void testTenantRepositoryCrud() {
        final Tenant tenant = new Tenant();

        tenant.setName("Wisconsin");
        tenant.setType(TenantType.STATE);
        this.tenantRepository.save(tenant);

        final String tenantId = tenant.getId();
        assertNotNull("id on saved Item should be not be null", tenantId);

        final Tenant readObj = this.tenantRepository.findOne(tenantId);
        assertEquals("State Name must be the same", readObj.getName(), "Wisconsin");

        this.tenantRepository.delete(readObj);
        assertNull("it should not exist", this.tenantRepository.findOne(readObj.getId()));

    }

    private void setupTestTenants() {
        final Tenant tenant = new Tenant();

        tenant.setName("WI");
        tenant.setDescription("Wisconsin (State)");
        tenant.setType(TenantType.STATE);
        this.tenantRepository.save(tenant);

        final Tenant tenant2 = new Tenant();
        tenant2.setName("MN");
        tenant2.setDescription("Minnesota (State)");
        tenant2.setType(TenantType.STATE);
        this.tenantRepository.save(tenant2);

        final Tenant tenant3 = new Tenant();
        tenant3.setName("CA");
        tenant3.setDescription("California (State)");
        tenant3.setType(TenantType.STATE);
        this.tenantRepository.save(tenant3);

        final Tenant tenant4 = new Tenant();
        tenant4.setName("Smarter Balanced");
        tenant4.setDescription("Smarter Balanced (Consortium)");
        tenant4.setType(TenantType.STATE_GROUP);
        this.tenantRepository.save(tenant4);

    }

    private List<ObjectId> setupTestTenantsWithSubscriptions() {
        final ObjectId componentId0 = new ObjectId();
        final ObjectId componentId1 = new ObjectId();
        final ObjectId componentId2 = new ObjectId();
        final ObjectId componentId3 = new ObjectId();
        final List<ObjectId> objectIds = Lists.newArrayList(componentId0, componentId1, componentId2, componentId3);

        final DateTime effectiveDate = DateTime.now();
        DateTime expirationDate = DateTime.now();
        expirationDate = expirationDate.plusYears(1);

        final List<Tenant> tenantList = Lists.newArrayList(
                new TenantBuilder("1", "name", "description", TenantType.STATE).addTenantSubscriptions(
                        new TenantSubscriptionBuilder(true, effectiveDate, expirationDate).addComponent(componentId0.toString(), "componentName0").build(),
                        new TenantSubscriptionBuilder(true, effectiveDate, expirationDate).addComponent(componentId1.toString(), "componentName1").build()
                        ).build(),
                new TenantBuilder("2", "name2", "description2", TenantType.STATE).addTenantSubscriptions(
                        new TenantSubscriptionBuilder(true, effectiveDate, expirationDate).addComponent(componentId0.toString(), "componentName0").build(),
                        new TenantSubscriptionBuilder(false, effectiveDate, expirationDate).addComponent(componentId1.toString(), "componentName1").build(),
                        new TenantSubscriptionBuilder(true, effectiveDate, expirationDate).addComponent(componentId2.toString(), "componentName2").build()
                        ).build(),
                new TenantBuilder("3", "name3", "description3", TenantType.STATE).addTenantSubscriptions(
                        new TenantSubscriptionBuilder(true, effectiveDate, expirationDate).addComponent(componentId0.toString(), "componentName0").build(),
                        new TenantSubscriptionBuilder(false, effectiveDate, expirationDate).addComponent(componentId3.toString(), "componentName3").build()
                        ).build()
                );

        this.tenantRepository.save(tenantList);
        return objectIds;
    }

    @Test
    public void testFindByTenantTypeAndName() {
        setupTestTenants();

        final Tenant readObj = this.tenantRepository.findByNameAndType("Smarter Balanced", TenantType.STATE_GROUP);
        assertNotNull(readObj);
        assertEquals("State Name must be the same", readObj.getName(), "Smarter Balanced");
        assertEquals("type must be the same ", readObj.getType(), TenantType.STATE_GROUP);

    }

    @Test
    public void testFindByTenantTypeAndNameNotFound() {
        setupTestTenants();
        final Tenant readObj = this.tenantRepository.findByNameAndType("Smarter Balanced asdf asdfas f", TenantType.STATE_GROUP);
        assertNull(readObj);

    }

    @Test
    public void testFindByTenantTypeAndNameAndTypeFlopped() {
        setupTestTenants();
        final Tenant readObj = this.tenantRepository.findByNameAndType("Smarter Balanced", TenantType.STATE);
        assertNull(readObj);
    }

    @Test
    public void testFindByParamsNoParams() {
        setupTestTenants();
        final Map<TenantType, String> params = Maps.newHashMap();
        final List<Tenant> tenantList = this.tenantRepository.findByNameAndType(params);
        assertNull(tenantList);
    }

    @Test
    public void testFindByNoParam() {
        setupTestTenants();
        final Map<TenantType, String> params = Maps.newHashMap();

        final List<Tenant> tenantList = this.tenantRepository.findByNameAndType(params);
        assertNull(tenantList);
    }

    @Test
    public void testFindByEmptyParams() {
        setupTestTenants();
        final Map<TenantType, String> params = Maps.newHashMap();
        params.put(TenantType.STATE, "");
        params.put(TenantType.STATE_GROUP, "");
        params.put(TenantType.DISTRICT, "");

        final List<Tenant> tenantList = this.tenantRepository.findByNameAndType(params);
        assertNull(tenantList);
    }

    @Test
    public void testFindByOneParam() {
        setupTestTenants();
        final Map<TenantType, String> params = Maps.newHashMap();
        params.put(TenantType.STATE, "WI");

        List<Tenant> tenantList = this.tenantRepository.findByNameAndType(params);
        assertNotNull(tenantList);
        assertEquals(1, tenantList.size());
        assertTrue("tenant not returned", tenantListContains(tenantList, TenantType.STATE, "WI"));

        params.put(TenantType.STATE, "MN");
        tenantList = this.tenantRepository.findByNameAndType(params);
        assertNotNull(tenantList);
        assertEquals(1, tenantList.size());
        assertTrue("tenant not returned", tenantListContains(tenantList, TenantType.STATE, "MN"));

        params.remove(TenantType.STATE);
        params.put(TenantType.STATE_GROUP, "Smarter Balanced");
        tenantList = this.tenantRepository.findByNameAndType(params);
        assertNotNull(tenantList);
        assertEquals(1, tenantList.size());
        assertTrue("tenant not returned", tenantListContains(tenantList, TenantType.STATE_GROUP, "Smarter Balanced"));
    }

    @Test
    public void testFindByMultiParams() {
        setupTestTenants();
        final Map<TenantType, String> params = Maps.newHashMap();
        params.put(TenantType.STATE, "WI");
        params.put(TenantType.STATE_GROUP, "Smarter Balanced");
        params.put(TenantType.DISTRICT, "FOO");
        params.put(TenantType.DISTRICT_GROUP, "FOO_BAR");

        final List<Tenant> tenantList = this.tenantRepository.findByNameAndType(params);
        assertNotNull(tenantList);
        assertEquals(2, tenantList.size());
        assertTrue("tenant not returned", tenantListContains(tenantList, TenantType.STATE, "WI"));
        assertTrue("tenant not returned", tenantListContains(tenantList, TenantType.STATE_GROUP, "Smarter Balanced"));

    }

    @Test
    public void testFindByNameRegexOrDescriptionRegex() {
        setupTestTenants();

        assertTrue("3 tenants should be found!", this.tenantRepository.findByNameRegexOrDescriptionRegexAndType("", "", TenantType.STATE, null).size() == 3);
        assertTrue("1 tenants should be found!", this.tenantRepository.findByNameRegexOrDescriptionRegexAndType("", "", TenantType.STATE_GROUP, null).size() == 1);
        assertTrue("3 tenants should be found!", this.tenantRepository.findByNameRegexOrDescriptionRegexAndType("name", "(State)", TenantType.STATE, null).size() == 3);
        assertTrue("3 tenants should be found!", this.tenantRepository.findByNameRegexOrDescriptionRegexAndType("name", "(state)", TenantType.STATE, null).size() == 3);
        assertTrue("2 tenants should be found!", this.tenantRepository.findByNameRegexOrDescriptionRegexAndType("name", "(State)", TenantType.STATE, new PageRequest(0, 2)).size() == 2);
        assertTrue("1 tenants should be found!", this.tenantRepository.findByNameRegexOrDescriptionRegexAndType("name", "Wisconsin", TenantType.STATE, null).size() == 1);
        assertTrue("1 tenants should be found!", this.tenantRepository.findByNameRegexOrDescriptionRegexAndType("name", "wisconsin", TenantType.STATE, null).size() == 1);
        assertTrue("0 tenants should be found!", this.tenantRepository.findByNameRegexOrDescriptionRegexAndType("name", "wiXXsconsin", TenantType.STATE, null).size() == 0);
        assertTrue("1 tenants should be found!", this.tenantRepository.findByNameRegexOrDescriptionRegexAndType("name", "wisconsin", null, null).size() == 1);
    }

    @Test
    public void testFindByComponentAndSearchVal() {
        setupTestTenantsWithSubscriptions();

        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName0", true, "descrip", TenantType.STATE, null).size(), is(equalTo(3)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName1", true, "descrip", TenantType.STATE, null).size(), is(equalTo(1)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName2", true, "descrip", TenantType.STATE, null).size(), is(equalTo(1)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName3", true, "descrip", TenantType.STATE, null).size(), is(equalTo(0)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName0", false, "descrip", TenantType.STATE, null).size(), is(equalTo(0)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName1", false, "descrip", TenantType.STATE, null).size(), is(equalTo(1)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName2", false, "descrip", TenantType.STATE, null).size(), is(equalTo(0)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName3", false, "descrip", TenantType.STATE, null).size(), is(equalTo(1)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName0", null, "descrip", TenantType.STATE, null).size(), is(equalTo(3)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName1", null, "descrip", TenantType.STATE, null).size(), is(equalTo(2)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName2", null, "descrip", TenantType.STATE, null).size(), is(equalTo(1)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName3", null, "descrip", TenantType.STATE, null).size(), is(equalTo(1)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName0", true, "name3", TenantType.STATE, null).size(), is(equalTo(1)));

        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName0", true, "", TenantType.STATE, new PageRequest(0, 2)).size(), is(equalTo(2)));
        assertThat(this.tenantRepository.findByComponentAndSearchVal("componentName0", true, "", TenantType.STATE, new PageRequest(1, 2)).size(), is(equalTo(1)));
    }

    @Test
    public void testFindByTenantSubscriptionsComponentId() {
        final List<ObjectId> componentIds = setupTestTenantsWithSubscriptions();

        final List<Tenant> searchResults0 = this.tenantRepository.findByTenantSubscriptionsComponentId(componentIds.get(0));
        final List<Tenant> searchResults1 = this.tenantRepository.findByTenantSubscriptionsComponentId(componentIds.get(1));
        final List<Tenant> searchResults2 = this.tenantRepository.findByTenantSubscriptionsComponentId(componentIds.get(2));
        final List<Tenant> searchResults3 = this.tenantRepository.findByTenantSubscriptionsComponentId(componentIds.get(3));
        final List<Tenant> searchResultsX = this.tenantRepository.findByTenantSubscriptionsComponentId(new ObjectId());

        assertEquals("3 groups should be found", searchResults0.size(), 3);
        assertEquals("2 groups should be found", searchResults1.size(), 2);
        assertEquals("1 group should be found", searchResults2.size(), 1);
        assertEquals("1 group should be found", searchResults3.size(), 1);
        assertEquals("0 groups should be found", searchResultsX.size(), 0);
    }

    @Test
    public void testCantSaveSubscriptionWithNoEffectiveDate() {
        setupTestTenantsWithSubscriptions();

        final List<Tenant> tens = this.tenantRepository.findByComponentAndSearchVal("componentName0", true, "", TenantType.STATE, new PageRequest(1, 2));
        final Tenant ten = tens.get(0);

        final TenantSubscription sub = ten.getTenantSubscriptions().get(0);
        sub.setEffectiveDate(null);
        ConstraintViolationException ex = null;
        try {
            this.tenantRepository.save(ten);
        } catch (final ConstraintViolationException e) {
            ex = e;
        }
        assertNotNull("A validation error for missing date should have been thrown", ex);
        assertTrue(ex.getConstraintViolations().iterator().next().getMessage().contains("tenantSubscription.effectiveDate.required"));
    }

    @Test
    public void testExpirationDateGreaterEqualToEffectiveDate() {
        setupTestTenantsWithSubscriptions();

        final List<Tenant> tens = this.tenantRepository.findByComponentAndSearchVal("componentName0", true, "", TenantType.STATE, new PageRequest(1, 2));
        final Tenant ten = tens.get(0);

        final TenantSubscription sub = ten.getTenantSubscriptions().get(0);
        sub.setEffectiveDate(DateTime.now());
        sub.setExpirationDate(DateTime.now());
        this.tenantRepository.save(ten);

        DateTime effectiveDate = DateTime.now();
        effectiveDate = effectiveDate.minusDays(1);
        sub.setEffectiveDate(effectiveDate);

        this.tenantRepository.save(ten);

        effectiveDate = DateTime.now();
        effectiveDate = effectiveDate.plusDays(1);
        sub.setEffectiveDate(effectiveDate);

        ConstraintViolationException ex = null;
        try {
            this.tenantRepository.save(ten);
        } catch (final ConstraintViolationException e) {
            ex = e;
        }
        assertNotNull("A validation error for missing date should have been thrown", ex);
        assertTrue(ex.getConstraintViolations().iterator().next().getMessage().contains("tenantSubscription.expirationDate.gtEffectiveDate"));
    }

    private boolean tenantListContains(final List<Tenant> tenants, final TenantType type, final String name) {
        boolean found = false;
        for (final Tenant t : tenants) {
            if (name.equals(t.getName()) && type.equals(t.getType())) {
                found = true;
            }
        }
        return found;
    }
}
