/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.shared.progman.encrypt;

import java.util.List;

import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.opentestsystem.shared.progman.domain.PropertyConfig;
import org.opentestsystem.shared.progman.domain.PropertyConfigAudit;
import org.opentestsystem.shared.progman.domain.PropertyEntry;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * This class is used as an Aspect to provide advice that runs for any service class that starts with PropertyConfig
 * and any method of matching classes that starts with save, get, or search. Thus, new methods can be created and will
 * automatically get encrypt/decrypt support.
 * Uses an encryption utility which uses Jasypt (www.jasypt.org) under the covers to provide 2-way
 * encryption/decryption of property values. This provides security of the property values at rest in the database.
 */
@Component
@Aspect
public class EncryptDecryptAspect {

    private static final Logger LOGGER = LoggerFactory.getLogger(EncryptDecryptAspect.class);

    @Autowired
    private EncryptionUtil encryptionUtil;

    /**
     * Pointcut for any save methods on any PropertyConfig service classes in the
     * org.opentestsystem.shared.progman.service.impl package
     */
    @Pointcut("execution(public * org.opentestsystem.shared.progman.service.impl.PropertyConfig*.save*(..))")
    public void saveMethod() {
        // empty
    }

    /**
     * Pointcut for any get methods on any PropertyConfig service classes in the
     * org.opentestsystem.shared.progman.service.impl package
     */
    @Pointcut("execution(public * org.opentestsystem.shared.progman.service.impl.PropertyConfig*.get*(..))")
    public void getMethod() {
        // empty
    }

    /**
     * Pointcut for any search methods on any PropertyConfig service classes in the
     * org.opentestsystem.shared.progman.service.impl package
     */
    @Pointcut("execution(public * org.opentestsystem.shared.progman.service.impl.PropertyConfig*.search*(..))")
    public void searchMethod() {
        // empty
    }

    /**
     * Pointcut to match methods with at least one argument named propertyConfig.
     * Binds the argument to a PropertyConfig type so that we can pass it into our advised method.
     * @param propertyConfig
     */
    @Pointcut("args(propertyConfig,..)")
    public void propertyConfigArg(final PropertyConfig propertyConfig) {
        // empty
    }

    /**
     * Encrypt any property values in the PropertyConfig object that need to be encrypted
     * @param propertyConfig
     */
    @Before("saveMethod() && propertyConfigArg(propertyConfig)")
    public void encrypt(final PropertyConfig propertyConfig) {
        LOGGER.debug("###### Encrypting ######");

        List<PropertyEntry> entries = propertyConfig.getProperties();

        for (PropertyEntry entry : entries) {
            if (entry.isEncrypt()) {
                String ciphertext = encryptionUtil.encrypt(entry.getPropertyValue());
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("for key = " + entry.getPropertyKey() + ": encrypting");
                }
                entry.setPropertyValue(ciphertext);
            } else {
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("key = " + entry.getPropertyKey() + ": not encrypting");
                }
            }
        }

        LOGGER.debug("###### Encrypting complete ######");
    }

    /**
     * Decrypt any property values in the PropertyConfig object that need to be decrypted
     * @param propertyConfig
     */
    @AfterReturning(pointcut = "getMethod() || searchMethod() || saveMethod()", returning = "propertyConfig")
    public void decrypt(final PropertyConfig propertyConfig) {
        LOGGER.debug("###### decrypting ######");

        if (propertyConfig != null) {
            List<PropertyEntry> entries = propertyConfig.getProperties();

            for (PropertyEntry entry : entries) {
                if (entry.isEncrypt()) {
                    String plaintext = encryptionUtil.decrypt(entry.getPropertyValue());
                    if (LOGGER.isDebugEnabled()) {
                        // LOGGER.debug("for key = " + entry.getPropertyKey() +
                        // ": ciphertext = " + entry.getPropertyValue() + ", plaintext = " + plaintext);
                        LOGGER.debug("for key = " + entry.getPropertyKey() + ": decrypting");
                    }
                    entry.setPropertyValue(plaintext);
                } else {
                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("key = " + entry.getPropertyKey() + ": not decrypting, already unencrypted");
                    }
                }
            }
        }

        LOGGER.debug("###### decrypting complete ######");

    }

    /**
     * Decrypt any property values in the SearchResponse that need to be decrypted. This function
     * is used for SearchResponse<PropertyConfig> and SearchResponse<PropertyConfigAudit>.
     * Due to type erasure with generic collections, the advice cannot be made more specific
     * than for a return type of SearchResponse<?>
     * @param searchResponse
     */
    @SuppressWarnings("unchecked")
    @AfterReturning(pointcut = "getMethod() || searchMethod()", returning = "searchResponse")
    public void decrypt(final SearchResponse<?> searchResponse) {
        LOGGER.debug("###### Decrypting wildcard ######");

        List<?> results = searchResponse.getSearchResults();
        if (results != null && !results.isEmpty()) {
            Object obj = results.get(0);

            if (obj instanceof PropertyConfig) {
                decryptSearchRespPropConfig((List<PropertyConfig>) results);
            } else if (obj instanceof PropertyConfigAudit) {
                decryptSearchRespPropConfigAudit((List<PropertyConfigAudit>) results);
            }
        }

        LOGGER.debug("###### Decrypting wildcard complete ######");
    }

    /**
     * Iterates through the List of PropertyConfig objects and calls the existing
     * decrypt method to decrypt fields in the PropertyConfig
     * @param results
     */
    private void decryptSearchRespPropConfig(final List<PropertyConfig> results) {
        for (PropertyConfig config : results) {
            decrypt(config);
        }
    }

    /**
     * Iterates through the List of PropertyConfigAudit objects, pulls out the PropertyConfig
     * object inside and calls the existing decrypt method to decrypt.
     * @param results
     */
    private void decryptSearchRespPropConfigAudit(final List<PropertyConfigAudit> results) {
        for (PropertyConfigAudit audit : results) {
            decrypt(audit.getPropertyConfig());
        }
    }

}
